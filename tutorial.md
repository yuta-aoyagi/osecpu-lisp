OSECPU-Lisp チュートリアル
==========================
この文章では, OSECPU-Lisp ver 0.0.1の使い方とプログラミング言語Lispの簡単な解説を行います.

起動と終了
----------
コマンドラインから`osecpu oseclisp.ose`を実行すると, OSECPU-Lispインタプリタが起動しすぐに入力待ちの状態になります.
プロンプトは用意していないので, この状態で入力を与えることになります.
`quit`と入力し改行してください.
インタプリタが終了します.

最初のプログラム
----------------
再びOSECPU-Lispを起動し, 今度は次の文字列を入力し改行してください.

    (quote foo)

次のような文字列が出力されるはずです.

    foo

そしてインタプリタは入力待ちの状態に戻ります.
これを確かめるため次のプログラムを入力してみましょう(以下, プログラムのことは文字列と言いませんし, いちいち改行せよとも言いません).

    (quote (Hello world))

次の出力が得られます.

    (Hello world)

これら以外の出力があった場合は, 入力が半角文字であること, `quote`が小文字であること, かっこの対応が取れていることを確認してください.

小さいですがこれがOSECPU-Lispにおけるプログラミングの一つの流れです.
つまり, 入力待ちのインタプリタにプログラムを与えると, それを実行した結果を出力し再び入力待ちの状態に戻り, これが繰り返されます.

S式とリスト
-----------
ここから少しの間, プログラムから離れてデータ構造の話をします.

LispのプログラムはS式という記法で表されたデータを操作できます.
S式の定義はごくシンプルです.

- アトムはS式である.
- 2つのS式をそれぞれ`x`, `y`とするとき, `(x . y)`はS式である.
- 上の2つの規則から作られる文字列のみがS式である.

OSECPU-Lispにおいてアトムとは, シンボルと組み込み関数のいずれかです.
組み込み関数についてはしばらく後で述べます.

OSECPU-Lispにおいてシンボルとは, 空白・かっこ・ピリオド`.`・制御文字のいずれも含まない連続した文字列のことです.
例を挙げましょう: `a`, `Hello!!`, `quote`, `123`, `*abc*`, `this-is-one-atom_with-long-name`.
アスタリスク`*`やエクスクラメーションマーク`!`, ハイフン`-`などの記号を含んでもよいことに注意してください.

上に挙げたシンボルの例を用いて, S式の例もいくつか示しましょう: `*abc*`, `(a . 123)`, `((Hello!! . a) . (123 . quote))`.

上で述べた定義だけでS式を書くと, 大量のかっことピリオドを扱うことになりやっかいです.
S式を空白で区切ってかっこで囲んだ文字列をリストといい, ある構造のS式の省略記法と見なされます.
リスト`(a b ... z)`は`(a . (b . ... (z . nil) ... ))`の省略です.
「開きかっこ, 1番目の要素, ピリオド, 開きかっこ, 2番目の要素, ピリオド」と繰り返して, 最後は「開きかっこ, 最後の要素, ピリオド, `nil`, 要素と同じ数の閉じかっこ」です.
`nil`というのはLispにおいて特別な役割をはたすシンボルです.
ここではリストの終わりを表しています.
この文字列が上で述べたS式の定義に当てはまっていることは, リストの長さに関する数学的帰納法で証明できます.

抽象的な定義を理解する助けになるよう, 具体例を挙げましょう: `(a b c)`は`(a . (b . (c . nil)))`と同等です.
`((a b) (c . d))`は`((a . (b . nil)) . ((c . d) . nil))`と同等です.
リスト記法のおかげでかっことピリオドが少なくシンプルな表現が可能になります.

境界的なケースについて示しましょう.
要素が2つのリスト`(a b)`は上の定義から`(a . (b . nil))`と同等です.
要素が1つのリスト`(a)`は`(a . nil)`と同等です.
要素がないリスト`()`はなんと`nil`と同等になります.
後でこの定義の優れている特徴を述べましょう.

リストの変種にも省略記法があります.
`(a b ... y . z)`は`(a . (b . ... (y . z) ... ))`の省略です.
リストの最後にピリオドともう1つのS式が付け加えられ, `nil`の代わりに使われています.

S式とリストに関して語ることは以上です.

ところで, 上の節で試したプログラムそのものもS式になっているのが分かるでしょうか.
`(quote (Hello world))`はS式`(quote ((Hello . (world . nil)) .nil))`と同等なのです.
OSECPU-Lispにこの右側のS式を入力しても同じ結果が得られます.

プログラムとデータが同じ記法で表されるという特徴は, 他の言語にはない極めて強い能力をLispに与えました.
このチュートリアルでは取り扱いませんが, 興味がある方は「Lisp マクロ」をキーワードに調べてみるとよいでしょう.

S式の入力
---------
インタプリタの働きをもう少し詳しく見てみましょう.
再びOSECPU-Lispインタプリタを起動し, 次のプログラムを1行ずつ入力してください.

    (quote
     (Hello
      world)
     )

最後の閉じかっこを入力するまでインタプリタは何の出力も返しません.
インタプリタはちょうど1つのS式が完成するまでを入力から読み取り, そのS式をプログラムとみなして実行するからです.
これ以降, シンボルを分断しない限りインタプリタの入力には好きなところに空白や改行を入れてかまいません.

S式の入力についておきうるエラーについて見ていきましょう.
閉じかっこ`)`だけを入力に与えて改行してください.

    Unexpected ')'
    nil

と出力が得られます.
これは, 正しいS式では現れない, 対応の取れない閉じかっこを検出したというエラーメッセージです.
次の行の`nil`は, それでも何らかの出力を返そうとOSECPU-Lispが内部ででっち上げた値です.

同様にただピリオド`.`だけを入力に与えると, `Unexpected '.'`とエラーメッセージを出力します.
ピリオドは対応の取れたかっこの中にだけ現れなければならないからです.

もう少しインタプリタをいじめてみましょう.
入力`(a . )`を与えてください.
ピリオドの後にはちょうど1つのS式がなければならないのに閉じかっこです.
インタプリタは`Unexpected ')'`と文句を言います.

では最後に, 入力`(a . b c)`を与えてみましょう.
ピリオドの後に置けるS式はちょうど1つなのにここには2つあります.
インタプリタは入力から`b`を読み, その次に閉じかっこがないのに気づいて`Missing ')'`とエラーを返します.

S式の入力についておきうるエラーはこれですべてです.
S式は定義が単純である分, おきうるエラーも種類が少なくなります.

上の節で, Lispのプログラムそれ自身もS式で表されるということを見ました.
少し確認してみましょう.
プログラム`(quote . (foo . nil))`を入力すると以前と同じ出力`foo`を得ます.
同様に`(quote . ((Hello . (world . nil)) . nil))`を入力すると出力`(Hello world)`が得られます.
入力ではリストの省略記法を使っていないのに出力では使われていることに注意してください.
インタプリタは入力のS式がリストの省略記法を使っているか否かを一切気にしません.
しかし出力の際には, 可能な限りリストの省略記法を使って短く出力しようとします.

評価と`quote`
-------------
LispはS式とリストにある程度知識がないとプログラムの解説もままならないので少し長めに解説しました.
最初のプログラム`(quote foo)`と`(quote (Hello world))`に戻りましょう.
実行結果から想像がつくと思いますが, `X`を任意のS式とすると`(quote X)`を実行した結果は`X`そのものになります.

LispでS式をプログラムとして実行することを, その式を「評価する」といいます.
以降, このチュートリアルでもそういいましょう.

組み込み関数
------------
次はもう少しプログラムらしいプログラムを書いてみましょう.
次のプログラムを評価してください.

    (atom (quote x))
    (atom (quote (x . a)))

結果はそれぞれ`t`と`nil`になります.
`t`というのも少し特別なシンボルです.
`(atom X)`を評価した結果は, `X`を評価した結果がアトムならば`t`, さもなくば`nil`です.

次のプログラムに行きましょう.

    (eq (quote x) (quote x))
    (eq (quote x) (quote a))

結果はそれぞれ`t`と`nil`になります.
`X`と`Y`を評価した結果がどちらもアトムである場合に`(eq X Y)`は定義されて, その結果のアトムが等しいならば`t`, さもなくば`nil`が結果になります.
`X`と`Y`の少なくとも一方を評価した結果がアトムでない場合の動作は未定義です.
したがって, 次のプログラムは不正です.

    (eq (quote (x . a)) (quote x))

次のプログラムを評価してください.

    (car (quote (x . a)))
    (car (quote ((x . a) . y)))

結果はそれぞれ`x`と`(x.a)`になります.
S式`X`を評価した結果がアトムでない場合にそれが`(X1.X2)`であるとすると, `(car X)`の結果は`X1`になります.
`X`を評価した結果がアトムの場合の動作は未定義です.
したがって, 次のプログラムは不正です.

    (eq (quote x))

`car`とよく似た`cdr`という関数もあります.
こちらは上の表記だと`X2`が評価結果になります.
具体例を挙げましょう.

    (cdr (quote (x . a)))
    (cdr (quote ((x . a) . y)))

結果はそれぞれ`a`と`y`です.
`cdr`も, 引数の評価結果がアトムの場合の動作は未定義で, `(cdr (quote x))`は不正です.

最後に次のプログラムを評価してください.

    (cons (quote x) (quote a))
    (cons (quote (x . a)) (quote y))

結果はそれぞれ`(x.a)`と`((x.a).y)`です.
`X`と`Y`を評価した結果がそれぞれ`X'`と`Y'`であるとすると, `(cons X Y)`を評価した結果は`(X'.Y')`です.

以上の`atom`, `eq`, `car`, `cdr`, `cons`の5つがOSECPU-Lispに用意された組み込み関数です.

上に挙げた定義からただちに,

    (eq (car (cons X Y)) X)
    (eq (cdr (cons X Y)) Y)

(ここで, `X`と`Y`は正しくプログラムになっている任意のS式とする)の2つのプログラムを評価すると常に`t`が結果となります.
同様に, 評価するとアトムでないS式になる任意のプログラムを`X`とするとき,

    (eq (cons (car X) (cdr X)) X)

を評価すると常に`t`が結果となります.

未完成
------
このチュートリアルは未完成です.
Pure Lispのチュートリアルを名乗るにはこの後少なくとも

- リストと`car`・`cdr`・`cons`の関係
- `cond`
- `lambda`
- 環境
- 不動点コンビネータ

などについて述べなくてはならないでしょう.
OSECPU-Lispに固有の説明としては少なくとも

- 組み込み関数というシンボルでないアトム

を, チュートリアルを超えてLisp言語全般については

- 高階関数
- eval
- マクロ

などについて述べるべきでしょう.
