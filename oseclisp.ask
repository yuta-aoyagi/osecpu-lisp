/**
 * @file oseclisp.ask
 * @brief OSECPU-VM上で動くLisp風言語のインタプリタ.
 * @author Yuta Aoyagi
 * @since 2013-09-10
 */

#include "osecpu_ask.h"

/// memmain の大きさ(T_SINT32単位).
#define MEMMAIN_SIZE	16 * 1024
/// symbuf の大きさ(T_UINT8単位).
#define SYMBUF_SIZE	16 * 1024
/// symidx の大きさ(T_SINT32).
#define SYMIDX_SIZE	16 * 1024

/**
 * @def BUG()
 * @brief #LISP_DEBUG がマクロ定義されていれば文字列"bug (行番号)"を標準出力に送る.
 * @note このマクロはR38を破壊する.
 * テンポラリのレジスタR30～R3Bのうち, R30はAPIの機能番号に, R31は引数である整数配列の長さに使われる.
 * R32とその先のいくつかは, 将来junk_putStringDec(がラップする生のAPI)が拡張される際に使われる可能性があると判断した(cf. page0053の下のほう).
 * R3Bとその前のいくつかは, 複雑な式の評価時にテンポラリとして使われるらしい(cf. page0043の(1)).
 * 以上の理由から, しばらくは使われないであろうR38を行番号の格納に使う.
 */
#ifdef LISP_DEBUG
	#define BUG() R38 = __LINE__; junkApi_putStringDec('bug \1', R38, 11, 1)
#else
	#define BUG() /* nothing to do */
#endif

/// #BUG() を呼んでからプログラムを終了する.
#define BUG_EXIT() BUG(); jnukApi_exit(1)

// 関数・データのラベル宣言.
#define L_print	LOCAL(0)
#define L_newPrint LOCAL(1)
#define L_STRINGS LOCAL(2)
LOCALLABELS(3);

#define print(x) R30 = x; CALL(L_print)
#define newPrint(x) P31 = x; CALL(L_newPrint)

// シンボルの名前文字列. 長さを8ビットで前に書くので最大255文字まで.
DAT_SA(L_STRINGS, T_UINT8, 11);
DB(3, 'n', 'i', 'l');
DB(6, 's', 'y', 'm', 'b', 'o', 'l');
DAT_END();

// グローバルなレジスタ割り当て.
VPtr memmain:P20;	//< Lispのオブジェクトを置く領域.
VPtr memmainPtr:P21;	//< memmain のうち未使用の領域の先頭.
VPtr symbuf:P22;	//< シンボルの名前を文字列として置く領域.
VPtr symbufPtr:P23;	//< symbuf のうち未使用の領域の先頭.
VPtr symidx:P24;	//< symbuf 内の添え字を置く領域.
VPtr symidxPtr:P25;	//< symidx のうち未使用の領域の先頭.

#define NIL 0		//< nilは memmain の先頭.

// main
do {
	VPtr p:P01;
	int32s sym:R02, cons:R03, cons2:R04;

	// メモリを確保する.
	junkApi_malloc(p, T_SINT32, MEMMAIN_SIZE);
	memmain = p;
	memmainPtr = memmain;
	junkApi_malloc(symbuf, T_UINT8, SYMBUF_SIZE);
	symbufPtr = symbuf;
	junkApi_malloc(symidx, T_SINT32, SYMIDX_SIZE);
	symidxPtr = symidx;

	// nilの実体を生成する.
	// これはmemmainの先頭に置く.
	R01 = 1; SMEM0PP(R01, T_SINT32, memmainPtr);
	R00 = 0; SMEM0PP(R00, T_SINT32, memmainPtr);

	// symbuf に文字列`sym'を置く.
	PDIF(R00, T_UINT8, symbufPtr, symbuf); SMEM0PP(R00, T_SINT32, symidxPtr);
	R00 = 's'; SMEM0PP(R00, T_UINT8, symbufPtr);
	R00 = 'y'; SMEM0PP(R00, T_UINT8, symbufPtr);
	R00 = 'm'; SMEM0PP(R00, T_UINT8, symbufPtr);
	R00 = 0;   SMEM0PP(R00, T_UINT8, symbufPtr);

	// シンボル`sym'のオブジェクトを生成する.
	PDIF(sym, T_SINT32, memmainPtr, memmain);
	SMEM0PP(R01, T_SINT32, memmainPtr);
	SMEM0PP(R01, T_SINT32, memmainPtr);
	R00 = 0; SMEM0PP(R00, T_SINT32, memmainPtr);

	// cons := (nil.sym)
	PDIF(cons, T_SINT32, memmainPtr, memmain);
	SMEM0PP(R01, T_SINT32, memmainPtr);
	R00 = 2; SMEM0PP(R00, T_SINT32, memmainPtr);
	PALMEM0(R00, T_SINT32, memmain, NIL); R00++; PASMEM0(R00, T_SINT32, memmain, NIL);
	R00 = NIL; SMEM0PP(R00, T_SINT32, memmainPtr);
	PALMEM0(R00, T_SINT32, memmain, sym); R00++; PASMEM0(R00, T_SINT32, memmain, sym);
	SMEM0PP(sym, T_SINT32, memmainPtr);

	// cons2 := (cons.sym)
	PDIF(cons2, T_SINT32, memmainPtr, memmain);
	SMEM0PP(R01, T_SINT32, memmainPtr);
	R00 = 2; SMEM0PP(R00, T_SINT32, memmainPtr);
	PALMEM0(R00, T_SINT32, memmain, cons); R00++; PASMEM0(R00, T_SINT32, memmain, cons);
	SMEM0PP(cons, T_SINT32, memmainPtr);
	PALMEM0(R00, T_SINT32, memmain, sym); R00++; PASMEM0(R00, T_SINT32, memmain, sym);
	SMEM0PP(sym, T_SINT32, memmainPtr);

	print(NIL);
	junkApi_putchar('\n');
	print(sym);
	junkApi_putchar('\n');
	print(cons);
	junkApi_putchar('\n');
	print(cons2);
}

/*
 * それぞれのLispのオブジェクトは, 長さ1以上のT_VPTRの配列と長さ2以上のT_SINT32の配列の組で表される.
 * vptr[0]はsint32の先頭へのポインタ.
 * sint32[0]は参照カウント, sint32[1]はオブジェクトの種類を現す整数値である.
 * 今のところ, 0はシンボル, 1はconsセルを表すことにしている.
 * ここまではすべてのオブジェクトに共通の構造である.
 * シンボルの場合は, vptr[1]にT_UINT8の配列の先頭へのポインタ, vptr[2]に直前に現れた新規のシンボルへのポインタが入る.
 * また, sint32[2]にシンボルの名前文字列の長さがバイト単位で入る.
 */

VPtr lastSym:P21, nil:P27;

do {
	VPtr p:P01, q:P02, r:P03;
	int32s i:R00, j:R01;

	// シンボルテーブルの番兵を生成する.
	junkApi_malloc(p, T_SINT32, 3);		// lastSym: pointer to head of array {1, 0, 0}.
	junkApi_malloc(lastSym, T_VPTR, 1);
	PSMEM0(p, T_VPTR, lastSym);
	i = 1; SMEM0PP(i, T_SINT32, p);
	i = 0; SMEM0PP(i, T_SINT32, p);
	SMEM0PP(i, T_SINT32, p);

	// シンボル`nil'を生成する.
	junkApi_malloc(p, T_VPTR, 3);
	i = 2; PAPSMEM0(lastSym, T_VPTR, p, i);
	lastSym = p;
	PLIMM(r, L_STRINGS);
	LMEM0PP(j, T_UINT8, r);
	i = 1; PAPSMEM0(r, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 3);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	i = 0; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(j, T_SINT32, q);

	PLMEM0(p, T_VPTR, lastSym);
	LMEM0(i, T_SINT32, p);
	i++;
	SMEM0PP(i, T_SINT32, p);
	nil = lastSym;

	junkApi_malloc(p, T_VPTR, 3);
	i = 2; PAPSMEM0(lastSym, T_VPTR, p, i);
	lastSym = p;
	PADD(r, T_UINT8, r, j);
	LMEM0PP(j, T_UINT8, r);
	i = 1; PAPSMEM0(r, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 3);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	i = 0; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(j, T_SINT32, q);

	VPtr sym:P04;
	PLMEM0(p, T_VPTR, lastSym);
	LMEM0(i, T_SINT32, p);
	i++;
	SMEM0PP(i, T_SINT32, p);
	sym = lastSym;

	junkApi_putchar2('\n', '\n');
	newPrint(nil);
	junkApi_putchar('\n');
	newPrint(sym);
}

/*
 * @brief 指定されたオブジェクトを表示する.
 *
 * 指定されたオブジェクトが不正ならば #BUG_EXIT() を呼ぶ.
 * @param[in] x:R30 表示するオブジェクト.
 */
beginFunc(L_print); do {
	int32s i:R00, x:R30;

	#ifdef LISP_DEBUG
		PALMEM0(i, T_SINT32, memmain, x);
		if (i <= 0) { BUG_EXIT(); }
	#endif

	x++;
	PALMEM0(i, T_SINT32, memmain, x);
	do {
		if (i == 0) {
			junkApi_putConstString('nil');
			break;
		}
		if (i == 1) {
			VPtr p:P01, q:P02;
			x++;
			PALMEM0(i, T_SINT32, memmain, x);
			PADD(p, T_UINT8, symbuf, i);
			q = p;
			do {
				LMEM0PP(i, T_UINT8, q);
				if (i != 0) continue;
			}
			PDIF(i, T_UINT8, q, p);
			i--;
			junkApi_putString2(i, p);
			break;
		}
		if (i == 2) {
			int32s t:R01;
			t = x + 1;
			junkApi_putchar('(');
			PALMEM0(i, T_SINT32, memmain, t);
			print(i);
			junkApi_putchar('.');
			t++;
			PALMEM0(i, T_SINT32, memmain, t);
			print(i);
			junkApi_putchar(')');
			break;
		}
		BUG_EXIT();
	}
} endFunc();

beginFunc(L_newPrint); do {
	VPtr x:P31, p:P01;
	int32s i:R00;

	PLMEM0(p, T_VPTR, x);
	#ifdef LISP_DEBUG
		LMEM0(i, T_SINT32, p);
		if (i <= 0) { BUG_EXIT(); }
	#endif

	i = 1; PALMEM0(i, T_SINT32, p, i);
	do {
		if (i == 0) {
			VPtr q:P02;
			i = 1; PAPLMEM0(q, T_VPTR, x, i);
			i = 2; PALMEM0(i, T_SINT32, p, i);
			junkApi_putString2(i, q);
			break;
		}
		BUG_EXIT();
	}
} endFunc();
