/**
 * @file oseclisp.ask
 * @brief OSECPU-VM上で動くLisp風言語のインタプリタ.
 * @author Yuta Aoyagi
 * @since 2013-09-10
 */

#include "osecpu_ask.h"

/**
 * @def BUG()
 * @brief #LISP_DEBUG がマクロ定義されていれば文字列"bug (行番号)"を標準出力に送る.
 * @note このマクロはR38を破壊する.
 * テンポラリのレジスタR30～R3Bのうち, R30はAPIの機能番号に, R31は引数である整数配列の長さに使われる.
 * R32とその先のいくつかは, 将来junk_putStringDec(がラップする生のAPI)が拡張される際に使われる可能性があると判断した(cf. page0053の下のほう).
 * R3Bとその前のいくつかは, 複雑な式の評価時にテンポラリとして使われるらしい(cf. page0043の(1)).
 * 以上の理由から, しばらくは使われないであろうR38を行番号の格納に使う.
 */
#ifdef LISP_DEBUG
	#define BUG() R38 = __LINE__; junkApi_putStringDec('bug \1', R38, 11, 1)
#else
	#define BUG() /* nothing to do */
#endif

/// #BUG() を呼んでからプログラムを終了する.
#define BUG_EXIT() BUG(); jnukApi_exit(1)

// 関数・データのラベル宣言.
%define L_STRINGS LOCAL(0)
#define L_incRef LOCAL(1)
#define L_decRef LOCAL(2)
#define L_intern LOCAL(3)
%define L_symFound LOCAL(4)
#define L_atom LOCAL(5)
#define L_eq LOCAL(6)
#define L_car LOCAL(7)
#define L_cdr LOCAL(8)
#define L_cons LOCAL(9)
#define L_skipBlank LOCAL(10)
#define L_read LOCAL(11)
#define L_print LOCAL(12)
LOCALLABELS(13);

#define incRef(x) P31 = x; CALL(L_incRef)
#define decRef(x) P31 = x; CALL(L_decRef)
#define intern(_s, len, p) R30 = len; P31 = p; CALL(L_intern); _s = P31
#define atom(_y, x) P31 = x; CALL(L_atom); _y = P31
#define eq(_z, x, y) P31 = x; P32 = y; CALL(L_eq); _z = P31
#define car(_y, x) P31 = x; CALL(L_car); _y = P31
#define cdr(_y, x) P31 = x; CALL(L_cdr); _y = P31
#define cons(_z, x, y) P31 = x; P32 = y; CALL(L_cons); _z = P31
#define skipBlank() CALL(L_skipBlank)
#define read(_x) CALL(L_read); _x = P31
#define print(x) P31 = x; CALL(L_print)

// シンボルの名前文字列. 長さを8ビットで前に書くので最大255文字まで.
DAT_SA(L_STRINGS, T_UINT8, 13);
DB(3, 'n', 'i', 'l');
DB(1, 't');
DB(6, 's', 'y', 'm', 'b', 'o', 'l');
DAT_END();

// グローバルなレジスタ割り当て.
VPtr lastSym:P20, nil:P21, symT:P22, null:P27;
int32s nextCh:R20;

#define nextChar() junkApi_inkey(nextCh, 2)

/*
 * それぞれのLispのオブジェクトは, 長さ1以上のT_VPTRの配列と長さ2以上のT_SINT32の配列の組で表される.
 * vptr[0]はsint32の先頭へのポインタ.
 * sint32[0]は参照カウント, sint32[1]はオブジェクトの種類を現す整数値である.
 * 今のところ, 0はシンボル, 1はconsセルを表すことにしている.
 * ここまではすべてのオブジェクトに共通の構造である.
 * シンボルの場合は, vptr[1]にT_UINT8の配列の先頭へのポインタ, vptr[2]に直前に現れた新規のシンボルへのポインタが入る.
 * また, sint32[2]にシンボルの名前文字列の長さがバイト単位で入る.
 * consセルの場合は, vptr[1]とvptr[2]にそれぞれcarとcdrが入る.
 */

// main
do {
	VPtr p:P01, q:P02;
	int32s i:R00;

	// シンボルテーブルの番兵を生成する.
	junkApi_malloc(p, T_SINT32, 3);		// lastSym: pointer to head of array {1, 0, 0}.
	junkApi_malloc(lastSym, T_VPTR, 1);
	PSMEM0(p, T_VPTR, lastSym);
	i = 1; SMEM0PP(i, T_SINT32, p);
	i = 0; SMEM0PP(i, T_SINT32, p);
	SMEM0PP(i, T_SINT32, p);

	// シンボル`nil'を生成する.
	PLIMM(q, L_STRINGS);
	LMEM0PP(i, T_UINT8, q);
	intern(p, i, q);
	incRef(p);
	nil = p;

	// シンボル`t'を生成する.
	PADD(q, T_UINT8, q, i);
	LMEM0PP(i, T_UINT8, q);
	intern(p, i, q);
	incRef(p);
	symT = p;

	// シンボル`symbol'を生成する.
	PADD(q, T_UINT8, q, i);
	LMEM0PP(i, T_UINT8, q);
	intern(p, i, q);
	VPtr sym:P03;
	incRef(p);
	sym = p;

	// consセルを2つ生成する.
	VPtr cons:P04, cons2:P05;
	cons(cons, nil, sym);
	cons(cons2, cons, sym);

	print(nil);
	junkApi_putchar('\n');
	print(sym);
	junkApi_putchar('\n');
	print(cons);
	junkApi_putchar('\n');
	print(cons2);

	// 上のテスト出力に使ったオブジェクトを解放する.
	// (symはシンボルテーブル内の参照が残るので, 参照カウントが1になり解放されない)
	decRef(cons2); cons2 = null;
	decRef(cons); cons = null;
	decRef(sym); sym = null;

	nextChar();

	read(p);
	print(p);
	junkApi_putchar('\n');
	PLIMM(q, L_atom); PLIMM(q, L_eq); PLIMM(q, L_car); PLIMM(q, L_cdr); // すべての関数を少なくとも一度触るため.
	cons(q, nil, p);
	print(q);
	decRef(q);
	decRef(p);
}

/*
 * @brief 指定されたオブジェクトの参照カウントを1増加する.
 *
 * 指定されたオブジェクトが不正ならば #BUG_EXIT() を呼ぶ.
 * @param[in,out] x:P31 対象とするオブジェクト.
 */
beginFunc(L_incRef); do {
	VPtr x:P31, p:P01;
	int32s i:R00;

	PLMEM0(p, T_VPTR, x);
	LMEM0(i, T_SINT32, p);
	#ifdef LISP_DEBUG
		if (i <= 0) { BUG_EXIT(); }
	#endif
	i++;
	SMEM0PP(i, T_SINT32, p);
} endFunc();

/*
 * @brief 指定されたオブジェクトの参照カウントを1減少する.
 * @param[in,out] x:P31 対象とするオブジェクト.
 */
beginFunc(L_decRef); do {
	VPtr x:P01, p:P02;
	int32s i:R00;

	x = P31;

	PLMEM0(p, T_VPTR, x);
	LMEM0(i, T_SINT32, p);
	#ifdef LISP_DEBUG
		if (i <= 0) { BUG_EXIT(); }
	#endif
	i--;
	if (i > 0) {
		SMEM0(i, T_SINT32, p);
		break;
	}
	i = 1; PALMEM0(i, T_SINT32, p, i);
	if (i == 1) {
		// ここでpを解放する.
		i = 1; PAPLMEM0(p, T_VPTR, x, i);
		decRef(p);
		i = 2; PAPLMEM0(p, T_VPTR, x, i);
		decRef(p);
		// ここでxを解放する.
		break;
	}
	BUG_EXIT();
} endFunc();

/*
 * @brief 指定された文字列を名前とするシンボルをシンボルテーブルから探し, なければ新規に登録して返す.
 * @param[in] P31 文字列の先頭へのポインタ.
 * @param[in] R30 文字列の長さ.
 * @retval (P31)シンボル.
 */
beginFunc(L_intern); do {
	VPtr p:P01, q:P02, r:P03;
	int32s len:R00, i:R01;

	p = P31;
	len = R30;

	q = lastSym;
	for (;;) {
		PLMEM0(r, T_VPTR, q);
		i = 2; PALMEM0(i, T_SINT32, r, i);
		if (i == 0) break;
		if (i == len) {
			r = p;
			VPtr s:P04;
			int32s j:R02;
			j = 1; PAPLMEM0(s, T_VPTR, q, j);
			do {
				int32s k:R03;
				LMEM0PP(j, T_UINT8, r);
				LMEM0PP(k, T_UINT8, s);
				if (j != k) break;
				i--; if (i > 0) continue;
			}
			if (i == 0) {
				P31 = q;
				goto symFound;
			}
		}
		i = 2; PAPLMEM0(q, T_VPTR, q, i);
	}
	junkApi_malloc(q, T_VPTR, 3);
	i = 2; PAPSMEM0(lastSym, T_VPTR, q, i);
	lastSym = q;
	i = 1; PAPSMEM0(p, T_VPTR, q, i);
	junkApi_malloc(p, T_SINT32, 3);
	PSMEM0(p, T_VPTR, q);
	i = 1; SMEM0PP(i, T_SINT32, p);
	i = 0; SMEM0PP(i, T_SINT32, p);
	SMEM0PP(len, T_SINT32, p);

	P31 = q;
LB0(L_symFound);
} endFunc();

/*
 * @brief 指定されたオブジェクトがアトムであるか否かを判定する.
 * @param[in] P31 判定するオブジェクト.
 * @return 指定されたオブジェクトがアトムならばt, さもなくばnil.
 */
beginFunc(L_atom); do {
	VPtr p:P01;
	int32s i:R00;
	PLMEM0(p, T_VPTR, P31);
	i = 1; PALMEM0(i, T_SINT32, p, i);
	if (i != 1) { p = symT; } else { p = nil; }
	incRef(p);
	P31 = p;
} endFunc();

/*
 * @brief 指定された2つのアトムが等しいかどうかを判定する.
 *
 * 指定された2つのオブジェクトのうち少なくとも一方がアトムでなければ結果は未定義である.
 * @return 指定された2つのアトムが等しいならばt, さもなくばnil.
 */
beginFunc(L_eq); do {
	VPtr p:P01;
	if (P31 == P32) { p = symT; } else { p = nil; }
	incRef(p);
	P31 = p;
} endFunc();

/*
 * @brief 指定されたconsセルのcarを返す.
 *
 * 指定されたオブジェクトがconsセルでなければ結果は未定義である.
 */
beginFunc(L_car); do {
	VPtr p:P01;
	int32s i:R00;
	PLMEM0(p, T_VPTR, P31);
	i = 1; PALMEM0(i, T_SINT32, p, i);
	if (i == 1) {
		PAPLMEM0(p, T_VPTR, P31, i);
	} else {
		junkApi_putConstString('car: not a cons\n');
		p = nil;
	}
	incRef(p);
	P31 = p;
} endFunc();

/*
 * @brief 指定されたconsセルのcdrを返す.
 *
 * 指定されたオブジェクトがconsセルでなければ結果は未定義である.
 */
beginFunc(L_cdr); do {
	VPtr p:P01;
	int32s i:R00;
	PLMEM0(p, T_VPTR, P31);
	i = 1; PALMEM0(i, T_SINT32, p, i);
	if (i == 1) {
		i++; PAPLMEM0(p, T_VPTR, P31, i);
	} else {
		junkApi_putConstString('cdr: not a cons.\n');
		p = nil;
	}
	incRef(p);
	P31 = p;
} endFunc();

/*
 * @brief 指定された2つのオブジェクトからconsセルを生成する.
 * @param[in] x:P31 car.
 * @param[in] y:P32 cdr.
 * @retval (P31)生成されたconsセル.
 */
beginFunc(L_cons); do {
	VPtr x:P31, y:P32, p:P01, q:P02, a:P03, b:P04;
	int32s i:R00;

	a = x; b = y;
	junkApi_malloc(p, T_VPTR, 3);
	incRef(a);
	i = 1; PAPSMEM0(a, T_VPTR, p, i);
	incRef(b);
	i = 2; PAPSMEM0(b, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 2);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(i, T_SINT32, q);

	P31 = p;
} endFunc();

// 標準入力から空白文字を読み飛ばす.
beginFunc(L_skipBlank); do {
	for (;;) {
		if (nextCh < 0) break;
		if (nextCh > ' ') break;
		nextChar();
	}
} endFunc();

/*
 * @brief 標準入力から次の式を読み取って返す.
 * @retval (P31)読み取られた式.
 */
beginFunc(L_read); do {
	VPtr p:P01;

	skipBlank();
	do {
		VPtr q:P02;
		int32s i:R00;

		if (nextCh == '(') {
			VPtr r:P03;

			nextChar();
			skipBlank();
			if (nextCh == ')') {
				incRef(nil);
				p = nil;
				break;
			}
			junkApi_malloc(p, T_VPTR, 3);
			junkApi_malloc(q, T_SINT32, 2);
			PSMEM0(q, T_VPTR, p);
			i = 1; SMEM0PP(i, T_SINT32, q);
			SMEM0PP(i, T_SINT32, q);
			r = p;
			for (;;) {
				read(q);
				i = 1; PAPSMEM0(q, T_VPTR, p, i);
				skipBlank();
				if (nextCh == ')') {
					incRef(nil);
					q = nil;
					nextChar();
					break;
				}
				if (nextCh == '.') {
					nextChar();
					read(q);
					skipBlank();
					if (nextCh == ')') {
						nextChar();
					} else {
						junkApi_putConstString('Missing \')\'\n');
					}
					break;
				}
				junkApi_malloc(q, T_VPTR, 3);
				i = 2; PAPSMEM0(q, T_VPTR, p, i);
				junkApi_malloc(p, T_SINT32, 2);
				PSMEM0(p, T_VPTR, q);
				i = 1; SMEM0PP(i, T_SINT32, p);
				SMEM0PP(i, T_SINT32, p);
				p = q;
			}
			i = 2; PAPSMEM0(q, T_VPTR, p, i);
			p = r;
			break;
		}
		if ((nextCh == ')') | (nextCh == '.')) {
			junkApi_putConstString('Unexpected \'');
			junkApi_putcharRxx(nextCh);
			junkApi_putchar2('\'', '\n');
			nextChar();
			incRef(nil);
			p = nil;
			break;
		}
		junkApi_malloc(p, T_UINT8, 32);
		q = p;
		do {
			SMEM0PP(nextCh, T_UINT8, q);
			nextChar();
			if ((nextCh > ' ') & (nextCh != '(') & (nextCh != ')') & (nextCh != '.')) continue;
		}
		PDIF(i, T_UINT8, q, p);
		intern(p, i, p);
		incRef(p);
	}
	P31 = p;
} endFunc();

/*
 * @brief 指定されたオブジェクトを表示する.
 *
 * 指定されたオブジェクトが不正ならば #BUG_EXIT() を呼ぶ.
 * @param[in] x:P31 表示するオブジェクト.
 */
beginFunc(L_print); do {
	VPtr x:P31, p:P01;
	int32s i:R00;

	PLMEM0(p, T_VPTR, x);
	#ifdef LISP_DEBUG
		LMEM0(i, T_SINT32, p);
		if (i <= 0) { BUG_EXIT(); }
	#endif

	i = 1; PALMEM0(i, T_SINT32, p, i);
	do {
		if (i == 0) {
			VPtr q:P02;
			i = 1; PAPLMEM0(q, T_VPTR, x, i);
			i = 2; PALMEM0(i, T_SINT32, p, i);
			junkApi_putString2(i, q);
			break;
		}
		if (i == 1) {
			p = x;
			junkApi_putchar('(');
			VPtr q:P02;
			for (;;) {
				VPtr r:P03;
				i = 1; PAPLMEM0(q, T_VPTR, p, i);
				print(q);

				i = 2; PAPLMEM0(q, T_VPTR, p, i);
				PLMEM0(r, T_VPTR, q);
				i = 1; PALMEM0(i, T_SINT32, r, i);
				if (i != 1) break;

				junkApi_putchar(' ');
				p = q;
			}
			if (q != nil) {	// 保証されていない比較演算.
				junkApi_putchar('.');
				print(q);
			}
			junkApi_putchar(')');
			break;
		}
		BUG_EXIT();
	}
} endFunc();
