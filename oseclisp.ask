/**
 * @file oseclisp.ask
 * @brief OSECPU-VM上で動くLisp風言語のインタプリタ.
 * @author Yuta Aoyagi
 * @since 2013-09-10
 */

#include "osecpu_ask.h"

/**
 * @def BUG()
 * @brief #LISP_DEBUG がマクロ定義されていれば文字列"bug (行番号)"を標準出力に送る.
 * @note このマクロはR38を破壊する.
 * テンポラリのレジスタR30～R3Bのうち, R30はAPIの機能番号に, R31は引数である整数配列の長さに使われる.
 * R32とその先のいくつかは, 将来junk_putStringDec(がラップする生のAPI)が拡張される際に使われる可能性があると判断した(cf. page0053の下のほう).
 * R3Bとその前のいくつかは, 複雑な式の評価時にテンポラリとして使われるらしい(cf. page0043の(1)).
 * 以上の理由から, しばらくは使われないであろうR38を行番号の格納に使う.
 */
#ifdef LISP_DEBUG
	#define BUG() R38 = __LINE__; junkApi_putStringDec('bug \1', R38, 11, 1)
#else
	#define BUG() /* nothing to do */
#endif

/// #BUG() を呼んでからプログラムを終了する.
#define BUG_EXIT() BUG(); jnukApi_exit(1)

// 関数・データのラベル宣言.
#define L_newPrint LOCAL(1)
#define L_STRINGS LOCAL(2)
#define L_incRef LOCAL(3)
#define L_newCons LOCAL(4)
LOCALLABELS(5);

#define newPrint(x) P31 = x; CALL(L_newPrint)
#define incRef(x) P31 = x; CALL(L_incRef)
#define newCons(_z, x, y) P31 = x; P32 = y; CALL(L_newCons); _z = P31

// シンボルの名前文字列. 長さを8ビットで前に書くので最大255文字まで.
DAT_SA(L_STRINGS, T_UINT8, 11);
DB(3, 'n', 'i', 'l');
DB(6, 's', 'y', 'm', 'b', 'o', 'l');
DAT_END();

// グローバルなレジスタ割り当て.
VPtr lastSym:P21, nil:P27;

/*
 * それぞれのLispのオブジェクトは, 長さ1以上のT_VPTRの配列と長さ2以上のT_SINT32の配列の組で表される.
 * vptr[0]はsint32の先頭へのポインタ.
 * sint32[0]は参照カウント, sint32[1]はオブジェクトの種類を現す整数値である.
 * 今のところ, 0はシンボル, 1はconsセルを表すことにしている.
 * ここまではすべてのオブジェクトに共通の構造である.
 * シンボルの場合は, vptr[1]にT_UINT8の配列の先頭へのポインタ, vptr[2]に直前に現れた新規のシンボルへのポインタが入る.
 * また, sint32[2]にシンボルの名前文字列の長さがバイト単位で入る.
 * consセルの場合は, vptr[1]とvptr[2]にそれぞれcarとcdrが入る.
 */

// main
do {
	VPtr p:P01, q:P02, r:P03;
	int32s i:R00, j:R01;

	// シンボルテーブルの番兵を生成する.
	junkApi_malloc(p, T_SINT32, 3);		// lastSym: pointer to head of array {1, 0, 0}.
	junkApi_malloc(lastSym, T_VPTR, 1);
	PSMEM0(p, T_VPTR, lastSym);
	i = 1; SMEM0PP(i, T_SINT32, p);
	i = 0; SMEM0PP(i, T_SINT32, p);
	SMEM0PP(i, T_SINT32, p);

	// シンボル`nil'を生成する.
	junkApi_malloc(p, T_VPTR, 3);
	i = 2; PAPSMEM0(lastSym, T_VPTR, p, i);
	lastSym = p;
	PLIMM(r, L_STRINGS);
	LMEM0PP(j, T_UINT8, r);
	i = 1; PAPSMEM0(r, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 3);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	i = 0; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(j, T_SINT32, q);

	incRef(lastSym);
	nil = lastSym;

	// シンボル`symbol'を生成する.
	junkApi_malloc(p, T_VPTR, 3);
	i = 2; PAPSMEM0(lastSym, T_VPTR, p, i);
	lastSym = p;
	PADD(r, T_UINT8, r, j);
	LMEM0PP(j, T_UINT8, r);
	i = 1; PAPSMEM0(r, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 3);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	i = 0; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(j, T_SINT32, q);

	VPtr sym:P04;
	incRef(lastSym);
	sym = lastSym;

	// consセルを2つ生成する.
	VPtr cons:P05, cons2:P06;
	newCons(cons, nil, sym);
	newCons(cons2, cons, sym);

	newPrint(nil);
	junkApi_putchar('\n');
	newPrint(sym);
	junkApi_putchar('\n');
	newPrint(cons);
	junkApi_putchar('\n');
	newPrint(cons2);
}

/*
 * @brief 指定されたオブジェクトを表示する.
 *
 * 指定されたオブジェクトが不正ならば #BUG_EXIT() を呼ぶ.
 * @param[in] x:P31 表示するオブジェクト.
 */
beginFunc(L_newPrint); do {
	VPtr x:P31, p:P01;
	int32s i:R00;

	PLMEM0(p, T_VPTR, x);
	#ifdef LISP_DEBUG
		LMEM0(i, T_SINT32, p);
		if (i <= 0) { BUG_EXIT(); }
	#endif

	i = 1; PALMEM0(i, T_SINT32, p, i);
	do {
		if (i == 0) {
			VPtr q:P02;
			i = 1; PAPLMEM0(q, T_VPTR, x, i);
			i = 2; PALMEM0(i, T_SINT32, p, i);
			junkApi_putString2(i, q);
			break;
		}
		if (i == 1) {
			p = x;
			junkApi_putchar('(');
			VPtr q:P02;
			i = 1; PAPLMEM0(q, T_VPTR, p, i);
			newPrint(q);
			junkApi_putchar('.');
			i = 2; PAPLMEM0(q, T_VPTR, p, i);
			newPrint(q);
			junkApi_putchar(')');
			break;
		}
		BUG_EXIT();
	}
} endFunc();

/*
 * @brief 指定されたオブジェクトの参照カウントを1増加する.
 *
 * 指定されたオブジェクトが不正ならば #BUG_EXIT() を呼ぶ.
 * @param[in,out] x:P31 対象とするオブジェクト.
 */
beginFunc(L_incRef); do {
	VPtr x:P31, p:P01;
	int32s i:R00;

	PLMEM0(p, T_VPTR, x);
	LMEM0(i, T_SINT32, p);
	#ifdef LISP_DEBUG
		if (i <= 0) { BUG_EXIT(); }
	#endif
	i++;
	SMEM0PP(i, T_SINT32, p);
} endFunc();

/*
 * @brief 指定された2つのオブジェクトからconsセルを生成する.
 * @param[in] x:P31 car.
 * @param[in] y:P32 cdr.
 * @retval (P31)生成されたconsセル.
 */
beginFunc(L_newCons); do {
	VPtr x:P31, y:P32, p:P01, q:P02, a:P03, b:P04;
	int32s i:R00;

	a = x; b = y;
	junkApi_malloc(p, T_VPTR, 3);
	incRef(a);
	i = 1; PAPSMEM0(a, T_VPTR, p, i);
	incRef(b);
	i = 2; PAPSMEM0(b, T_VPTR, p, i);
	junkApi_malloc(q, T_SINT32, 2);
	PSMEM0(q, T_VPTR, p);
	i = 1; SMEM0PP(i, T_SINT32, q);
	SMEM0PP(i, T_SINT32, q);

	P31 = p;
} endFunc();
